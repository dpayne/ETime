package com.etrade.etime;

import android.app.Activity;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.os.CountDownTimer;
import android.preference.PreferenceManager;
import android.util.Log;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.webkit.*;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.impl.client.DefaultHttpClient;

import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

public class ETimeActivity extends Activity {

    private String PREFS_USERNAME = "username";
    private String PREFS_PASSWORD = "password";

    private WebView webview;
    private DefaultHttpClient httpClient;
    final Activity activity = this;

    private String loginName = null;
    private String password = null;

    private String TAG = "ETime-4321";
    private String PREF_LUNCH = "lunch";

    private String TIMESTAMP_RECORD_URL;
    private String TIMECARD_URL;

    private String TIMESTAMP_URL;
    private String TIMESTAMP_SUCCESS;
    private String LOGIN_FAILED_URL;

    private long loginTime;

    final private long DEF_TIMEOUT = 900000; // 15 mins in milliseconds
    private static final long MY_COUNT_INTERVAL = 300000; // 5 mins in milliseconds

    private ProgressBar progressBar;
    private Button recordTime;

    private List<Punch> punches;
    private double totalHrs;
    private String oldLoginNameBeforePreferencePage;
    private String LOGIN_FAILED_URL_2;

    private Button curStatus;
    private Button textViewTotalHrs;
    private TextView loading;
    private Button timeToClockOut;

    private Punch lastPunch;
    private boolean AUTO_CLOCKOUT;

    private NotificationManager mManager;
    private static final int APP_ID = 1;
    
    private MyCount autoClockOutTimer;

    private boolean notCreated = true;
    private boolean autoClockOutIfOkTimeCard;
    private boolean oldAutoClockBeforePreferencePage;
    private CookieManager cookieManager;
    private Button totalHrsLoggedToday;

    /*
    * todo: auto clock in/out for lunch
    *
    */

    /**
     * Called when the activity is first created.
     */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    }
    
    @Override
    public void onResume() {
        super.onResume();
        if (validConfig()) {
            setupTitlePage();
        } else { /* show config page, to set username password */
            Toast.makeText(getApplicationContext(), "Username/Password required", Toast.LENGTH_LONG).show();
            startPreferencesPage();
        }
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if(mManager != null)
        	mManager.cancel(APP_ID);
    }
    
    private void notify(String message){
    	int icon = R.drawable.icon;
    	CharSequence tickerText = message;
    	long when = System.currentTimeMillis();
    	Context context = getApplicationContext();
    	CharSequence contentTitle = "ETime";
    	CharSequence contentText = message;
    	Intent notificationIntent = new Intent(this,ETimeActivity.class);
    	PendingIntent contentIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
    	
    	mManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
    	Notification notification = new Notification(icon, tickerText, when);
    	notification.flags |= Notification.DEFAULT_LIGHTS;
    	//notification.defaults |= Notification.DEFAULT_SOUND;
    	notification.defaults |= Notification.DEFAULT_VIBRATE;
        notification.flags |= Notification.FLAG_ONGOING_EVENT;
    	notification.setLatestEventInfo(context, contentTitle, contentText, contentIntent);
    	mManager.notify("ETime", APP_ID, notification);
    }
    
    protected void startPreferencesPage() {
        oldLoginNameBeforePreferencePage = loginName;
        oldAutoClockBeforePreferencePage = AUTO_CLOCKOUT;
        startActivity(new Intent(activity, ETimePreferences.class));
    }

    private WebView setupWebView(WebView webview) {

        webview.getSettings().setJavaScriptEnabled(true);
        webview.getSettings().setJavaScriptCanOpenWindowsAutomatically(true);
        webview.getSettings().setAllowFileAccess(true);
        webview.getSettings().setBuiltInZoomControls(true);
        webview.getSettings().setSupportZoom(true);
        webview.canGoBack();

        webview.setWebViewClient(new MyWebViewClient());
        webview.setWebChromeClient(new MyWebChromeClient());

        return webview;
    }

    public void setPunches(List<Punch> punches) {
        this.punches = punches;
    }

    public void setTotalHrs(double totalHrs) {
        this.totalHrs = totalHrs;
    }

    public void onPostParsingTimeCard() {
    	Log.v(TAG, "in post timecard");
        textViewTotalHrs.setText("Total Hrs this pay period: " + totalHrs);
        totalHrsLoggedToday.setText("Total Hrs Today: " + todaysTotalHrsLogged());
        if (punches.size() > 0) {
            lastPunch = punches.get(punches.size()-1);
            if (lastPunch != null) {
                StringBuilder sb = new StringBuilder("Clocked ");
                if (lastPunch.isClockIn()) {
                    sb.append("in ");
                } else {
                    sb.append("out ");
                }
                sb.append("at ");
                Calendar lastPunchCalendar = lastPunch.getCalendar();
                sb.append(Integer.toString(getHourFromCalendar(lastPunchCalendar))).append(":");

                int minute = lastPunch.getCalendar().get(Calendar.MINUTE);
                if (minute < 10) {
                    sb.append("0");
                }
                sb.append(Integer.toString(minute));

                if (lastPunchCalendar.get(Calendar.AM_PM) == Calendar.AM) {
                    sb.append(" AM");
                } else {
                    sb.append(" PM");
                }

                curStatus.setText(sb.toString());

                Punch eightHrPunch = getEightHrPunch();
                Calendar eightHrPunchCalendar = eightHrPunch.getCalendar();

                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Clock out at ");
                
                StringBuilder clockTimeString = new StringBuilder();

                clockTimeString.append(Integer.toString(getHourFromCalendar(eightHrPunchCalendar))).append(":");

                int min = eightHrPunchCalendar.get(Calendar.MINUTE);
                if (min < 10) {
                	clockTimeString.append("0");
                }
                clockTimeString.append(Integer.toString(min));

                if (eightHrPunchCalendar.get(Calendar.AM_PM) == Calendar.AM) {
                	clockTimeString.append(" AM");
                } else {
                	clockTimeString.append(" PM");
                }

                stringBuilder.append(clockTimeString);
                timeToClockOut.setText(stringBuilder.toString());
<<<<<<< .mine
                if (autoClockOutIfOkTimeCard && lastPunch.isClockIn()) {
                    clockOut();
                    autoClockOutIfOkTimeCard = false;

                    return;
=======
                
                if(AUTO_CLOCKOUT){
                	Log.v(TAG, "in auto clock out");
	                if (autoClockOutIfOkTimeCard && lastPunch.isClockIn()) {
	                	Log.v(TAG, "ready to clock out");
	                    clockOut();
	                    autoClockOutIfOkTimeCard = false;
	
	                    return;
	                }
	                autoClockOutIfOkTimeCard = false;
	
	                long countDownTime = eightHrPunch.getCalendar().getTimeInMillis() - Calendar.getInstance().getTimeInMillis();
	                countDownTime = DEF_TIMEOUT*2;
	                if (countDownTime > 0 && lastPunch.isClockIn()) {
	                    if (autoClockOutTimer != null) {
	                        autoClockOutTimer.cancel();
	                    }
	                    autoClockOutTimer = new MyCount(countDownTime, MY_COUNT_INTERVAL);
	                    autoClockOutTimer.start();
	                    ETimeActivity.this.notify("Auto clock out at: "+clockTimeString);
	                }
>>>>>>> .r68459
                }
                autoClockOutIfOkTimeCard = false;

                long countDownTime = eightHrPunch.getCalendar().getTimeInMillis() - Calendar.getInstance().getTimeInMillis();
                if (countDownTime > 0 && lastPunch.isClockIn()) {
                    if (autoClockOutTimer != null) {
                        autoClockOutTimer.cancel();
                    }
                    autoClockOutTimer = new MyCount(countDownTime, MY_COUNT_INTERVAL);
                    autoClockOutTimer.start();
                    ETimeActivity.this.notify("Auto clock out at: "+clockTimeString);
                }
            }
        }
    }

    private int getHourFromCalendar(Calendar calendar) {
        int hour24 = calendar.get(Calendar.HOUR_OF_DAY);

        if (hour24 == 0) //12 AM
        {
            return 12;
        } else if (hour24 > 12) {
            return (hour24 - 12);
        } else {
            return hour24;
        }
    }

    private Punch getLastClockIn() {
        Punch lastClockIn = null;
        for (Punch punch : punches) {
            if (punch.isClockIn()) {
                lastClockIn = punch;
            }
        }
        return lastClockIn;
    }

    private Punch getEightHrPunch() {
        Punch eightHrPunch = new Punch();
        Punch lastClockIn = getLastClockIn();
        Calendar calendar;

        if (lastClockIn == null || (lastPunch != null && !lastPunch.isClockIn())) {
            calendar = Calendar.getInstance();
        } else {
            calendar = lastClockIn.getCalendar();
        }

        eightHrPunch.setClockIn(false);

        double totalHrsLoggedToday = todaysTotalHrsLogged();

        if (totalHrsLoggedToday >= 8.0) {
            eightHrPunch.setCalendar(Calendar.getInstance());
            return eightHrPunch;
        }
        double timeLeft = 8.0 - totalHrsLoggedToday;

        int hrs = (int) timeLeft;
        int mins = (int) ((timeLeft - Math.floor(timeLeft)) * 60);

        int curHr = calendar.get(Calendar.HOUR_OF_DAY);
        int curMin = calendar.get(Calendar.MINUTE);

        hrs += ((mins + curMin) / 60 + curHr) % 24;
        mins = (mins + curMin) % 60;

        calendar.set(Calendar.HOUR_OF_DAY, hrs);
        calendar.set(Calendar.MINUTE, mins);

        eightHrPunch.setCalendar(calendar);

        return eightHrPunch;
    }

    private double todaysTotalHrsLogged() {
        long runningMilliSecTotal = 0;
        Punch curInPunch;
        Punch curOutPunch;
        Iterator<Punch> iterPunches = punches.iterator();

        while (true) {
            //get next clock in
            if (!iterPunches.hasNext())
                break;

            curInPunch = iterPunches.next();

            //get next clock out
            if (!iterPunches.hasNext()) {
                curOutPunch = new Punch();
                curOutPunch.setCalendar(Calendar.getInstance());
                curOutPunch.setClockIn(false);
                break;
            } else {
                curOutPunch = iterPunches.next();
            }

            runningMilliSecTotal += curOutPunch.getCalendar().getTimeInMillis() - curInPunch.getCalendar().getTimeInMillis();
        }
        double hrs = (((runningMilliSecTotal / 1000) / 60) / 60) % 24;
        double mins = (((runningMilliSecTotal / 1000) / 60) % 60) / 100.0;

        return hrs + mins;
    }

    public void onPostLogin() {
    	Log.v(TAG, "in postLogin");
        hideProgressBar();

        loginTime = Calendar.getInstance().getTimeInMillis();
        showTitlePageBtns();
        parseTimeCard();
    }

    private class MyWebChromeClient extends WebChromeClient {
        public void onProgressChanged(WebView view, int progress) {
            progressBar.setProgress(progress);
        }
    }

    private void setupGlobals() {
        loginTime = 0;
        httpClient = new DefaultHttpClient();
        lastPunch = null;


        TIMESTAMP_RECORD_URL = getString(R.string.timestamp_record_url);
        TIMECARD_URL = getString(R.string.timecard_url);

        TIMESTAMP_URL = getString(R.string.timestamp_url);
        TIMESTAMP_SUCCESS = getString(R.string.timestamp_success_url);
        LOGIN_FAILED_URL = getString(R.string.login_failed_url);
        LOGIN_FAILED_URL_2 = getString(R.string.login_failed_url_2);

        webview = (WebView) findViewById(R.id.web_engine);
        webview = setupWebView(webview);
        cookieManager = getSyncedCookieManager();

        progressBar = (ProgressBar) findViewById(R.id.pb_progressBar);
        recordTime = (Button) findViewById(R.id.btn_recordTime);
        textViewTotalHrs = (Button) findViewById(R.id.btn_totalHrs);
        totalHrsLoggedToday = (Button) findViewById(R.id.btn_totalHrsToday);
        curStatus = (Button) findViewById(R.id.btn_curStatus);
        loading = (TextView) findViewById(R.id.tv_load);
        timeToClockOut = (Button) findViewById(R.id.btn_timeToClockOut);
    }

    private void setupTitlePage() {
        if (notCreated) {
            setContentView(R.layout.title_page);

            setupGlobals();
            setupButtons();
            notCreated = false;
        }

        login();
    }

    private CookieManager getSyncedCookieManager() {
        CookieSyncManager cookieSyncManager = CookieSyncManager.createInstance(webview.getContext());
        CookieManager cookieManager = CookieManager.getInstance();
        cookieManager.setAcceptCookie(true);
        cookieManager.removeSessionCookie();
        cookieSyncManager.sync();
        return cookieManager;
    }


    private void login() {
    	Log.v(TAG, "in login");
        long curTime = Calendar.getInstance().getTimeInMillis();

        setTitle("ETime - " + loginName);

        if ((curTime - loginTime) > DEF_TIMEOUT || (oldLoginNameBeforePreferencePage != null && !oldLoginNameBeforePreferencePage.equals(loginName))) {
        	Log.v(TAG, "timed out");
            if (oldLoginNameBeforePreferencePage != null && !oldLoginNameBeforePreferencePage.equals(loginName)) {
                //loadUrl("https://eet.adp.com/wfc/applications/kss/html/CustomLogoff.jsp");
                cookieManager.removeSessionCookie();
                cookieManager.removeAllCookie();
                //cookieManager.setCookie("https://eet.adp.com/", "");
                //cookieManager = getSyncedCookieManager();
            }

            LoginAsyncTask loginAsyncTask = new LoginAsyncTask();
            progressBar.setProgress(0);

            httpClient = new DefaultHttpClient();
            httpClient.getCredentialsProvider().setCredentials(new AuthScope(null, -1),
                    new UsernamePasswordCredentials(loginName, password));
            loginAsyncTask.setProgressBar(progressBar);
            loginAsyncTask.setActivity(this);
            loginAsyncTask.setCookieManager(cookieManager);
            loginAsyncTask.setHttpClient(httpClient);
            loginAsyncTask.setContext(getApplicationContext());
            loginAsyncTask.execute();
        } else {
        	Log.v(TAG, "did not time out");
            hideProgressBar();
            showTitlePageBtns();
            if ((AUTO_CLOCKOUT != oldAutoClockBeforePreferencePage) || (autoClockOutIfOkTimeCard)) {
                parseTimeCard();
            }
        }
        oldAutoClockBeforePreferencePage = AUTO_CLOCKOUT;

    }

    private void setupButtons() {
        recordTime.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                clockOut();
            }
        });
    }

    protected void startTimeCardActivity() {
        Intent intent = new Intent(activity, TimeCardActivity.class);
        intent.putExtra("loginName", loginName);
        intent.putExtra("password", password);
        startActivity(intent);
    }

    protected void parseTimeCard() {
    	Log.v(TAG, "in timecard");
        TimeCardAsyncTask timeCardAsyncTask = new TimeCardAsyncTask();
        timeCardAsyncTask.setActivity((ETimeActivity) activity);
        timeCardAsyncTask.setHttpClient(httpClient);
        timeCardAsyncTask.setProgressBar(progressBar);
        timeCardAsyncTask.execute();
    }

    protected void hideTitlePageBtns() {
        recordTime.setVisibility(View.GONE);
        curStatus.setVisibility(View.GONE);
        textViewTotalHrs.setVisibility(View.GONE);
        totalHrsLoggedToday.setVisibility(View.GONE);
        timeToClockOut.setVisibility(View.GONE);
    }

    protected void showTitlePageBtns() {
        recordTime.setVisibility(View.VISIBLE);
        curStatus.setVisibility(View.VISIBLE);
        textViewTotalHrs.setVisibility(View.VISIBLE);
        totalHrsLoggedToday.setVisibility(View.VISIBLE);
        timeToClockOut.setVisibility(View.VISIBLE);
    }

    protected void hideProgressBar() {
        progressBar.setVisibility(View.GONE);
        loading.setVisibility(View.GONE);
    }

    protected void showProgressBar() {
        progressBar.setVisibility(View.VISIBLE);
        loading.setVisibility(View.VISIBLE);
    }

    private boolean validConfig() {
        SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(activity);
        loginName = pref.getString(PREFS_USERNAME, null);
        password = pref.getString(PREFS_PASSWORD, null);
        AUTO_CLOCKOUT = pref.getBoolean(getString(R.string.autoclock), false);
        
        if(AUTO_CLOCKOUT != oldAutoClockBeforePreferencePage && autoClockOutTimer != null){
        	autoClockOutTimer.cancel();
        	ETimeActivity.this.notify("Auto clock out cancelled!");
        }        	

        return (loginName != null && !loginName.equals("")) && (password != null && !password.equals(""));
    }

    private class MyWebViewClient extends WebViewClient {
        @Override
        public void onReceivedHttpAuthRequest(WebView view,
                                              HttpAuthHandler handler, String host, String realm) {
            handler.proceed(loginName, password);
        }

        @Override
        public boolean shouldOverrideUrlLoading(WebView view, String url) {
            view.loadUrl(url);
            return true;
        }

        @Override
        public void onPageFinished(WebView view, String url) {
            Log.v(TAG, url);
            if (url.equals(TIMESTAMP_URL)) {
                hideProgressBar();

                showTitlePageBtns();
            } else if (url.equals(TIMESTAMP_SUCCESS)) {
                hideProgressBar();

                parseTimeCard();
                showTitlePageBtns();
                Toast.makeText(getApplicationContext(), "Time Stamp Successful", Toast.LENGTH_LONG).show();
                
            } else if (url.equals(TIMECARD_URL)) {
                hideProgressBar();

                webview.setVisibility(View.VISIBLE);

            } else if (url.equals(LOGIN_FAILED_URL) || url.equals(LOGIN_FAILED_URL_2)) {
                hideProgressBar();

                Toast.makeText(getApplicationContext(), "Invalid Username/Password", Toast.LENGTH_LONG).show();
                startPreferencesPage();
            }
        }

        @Override
        public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
            hideProgressBar();

            Toast.makeText(getApplicationContext(), "Unable to connect to service", Toast.LENGTH_LONG).show();
        }
    }

    private class MyCount extends CountDownTimer {
        public MyCount(long millisInFuture, long countDownInterval) {
            super(millisInFuture, countDownInterval);
        }

        @Override
        public void onFinish() {
            Toast.makeText(getApplicationContext(), "Done with 8 hours. Time to clock out!", Toast.LENGTH_LONG).show();

            if (AUTO_CLOCKOUT) {
            	Log.v(TAG, "in onFinish");
                autoClockOutIfOkTimeCard = true;
                login();
                ETimeActivity.this.notify("Auto clocked out!");
            }else{
            	ETimeActivity.this.notify("Auto clock out cancelled by user!");
            }
        }

        @Override
        public void onTick(long millisUntilFinished) {
        }

    }

    private void clockOut() {
        Log.v(TAG, "clocked out");
        hideTitlePageBtns();
        showProgressBar();
        //webview.loadUrl(TIMESTAMP_RECORD_URL);
        webview.loadUrl(TIMECARD_URL);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.menu, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.menu_preferences:
                startPreferencesPage();
                break;
            case R.id.menu_timecard:
                startTimeCardActivity();
                break;
        }
        return true;
    }

    protected void loadUrl(String url) {
        hideTitlePageBtns();
        showProgressBar();
        webview.loadUrl(url);
    }
    
    @Override
    public void onBackPressed() {
       Log.d(TAG, "onBackPressed Called");
       SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(activity);
       if(pref.getBoolean(getString(R.string.keepInBackground), true)){
	       Intent setIntent = new Intent(Intent.ACTION_MAIN);
	       setIntent.addCategory(Intent.CATEGORY_HOME);
	       setIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
	       startActivity(setIntent);
       }else{
    	   super.onBackPressed();
       }
    }
}
